<!DOCTYPE html>
<html lang="en">

<head>
    <title>WebRTC grabber</title>
    <style>
        button {
            font-size: 24pt;
            text-decoration: none;
            display: inline-block;
            padding: 10px 30px;
            margin: 10px 20px;
            position: relative;
            overflow: hidden;
            border: 2px solid #b12a1c;
            border-radius: 8px;
            color: #b12a1c;
            transition: .2s ease-in-out;
            background: inherit;
        }

        button:hover {
            background: #b12a1c;
            color: #ffffff;
        }

        #captureButton:hover {
            color: #ffffff !important;
        }

        #captureButton.detecting {
            border-color: #4a82c3;
            color: #4a82c3;
        }

        #captureButton.detecting:hover {
            background: #4a82c3;
        }

        #captureButton.connecting {
            border-color: #fdba31;
            color: #fdba31;
        }

        #captureButton.connecting:hover {
            background: #fdba31;
        }

        #captureButton.active {
            border-color: #1eb11c;
            color: #1eb11c;
        }

        #captureButton.active:hover {
            background: #1eb11c;
        }

        #captureButton.recording {
            border-color: #ff0000;
            color: #ff0000;
        }

        #captureButton.recording:hover {
            background: #ff0000;
        }
    </style>
    <script src="/sockets.js"></script>
</head>

<body>
    <div style="text-align: center">
        <button id="allowAccess" style="display: none">Allow access</button>
        <button id="captureButton">Capture</button>
    </div>
</body>

</html>
<script>
    const webcamConstraint = { aspectRatio: 16 / 9 };
    const webcamAudioConstraint = true;
    const desktopConstraint = {
        video: {
            displaySurface: "window"
        }
    };

    const requireAuth = () => {
        if (localStorage.getItem("adminCredentials")) {
            return localStorage.getItem("adminCredentials");
        }
        const credentialInput = prompt("Admin credentials");
        localStorage.setItem("adminCredentials", credentialInput);
        return credentialInput;
    }

    class GrabberCaptureClient {
        constructor(peerName) {
            this.peerName = peerName;
            this.target = new EventTarget();
            this.signallingUrl = window.location.origin;

            const socketPath = "/ws/peers/" + peerName;

            this.socket = new GrabberSocket(socketPath);
            this.socket.on("connect", async () => {
                console.log("init socket", socketPath);
            });

            const init_peer_handle = function ({ initPeer: { pcConfig, pingInterval } }) {
                this.target.dispatchEvent(new CustomEvent('init_peer', { detail: { pcConfig, pingInterval } }));
            };
            const offer_handle = async function ({ offer: { peerId, offer, streamType } }) {
                this.target.dispatchEvent(new CustomEvent('offer', { detail: { playerId: peerId, offer, streamType } }));
            }
            const player_ice_handle = async function ({ ice: { peerId, candidate } }) {
                this.target.dispatchEvent(new CustomEvent('player_ice', { detail: { peerId, candidate } }));
            }
            const record_start_handle = async function ({ recordStart: { recordId, timeout } }) {
                this.target.dispatchEvent(new CustomEvent('record_start', { detail: { recordId, timeout } }));
            }
            const record_stop_handle = async function ({ recordStop: { recordId } }) {
                this.target.dispatchEvent(new CustomEvent('record_stop', { detail: { recordId } }));
            }
            const record_upload_handle = async function ({ recordUpload: { recordId } }) {
                this.target.dispatchEvent(new CustomEvent('record_upload', { detail: { recordId } }));
            }
            const players_disconnect_handle = async function ({ event }) {
                this.target.dispatchEvent(new CustomEvent("players_disconnect", { detail: {} }));
            }

            this.socket.on("init_peer", init_peer_handle.bind(this));
            this.socket.on("offer", offer_handle.bind(this));
            this.socket.on("player_ice", player_ice_handle.bind(this));
            this.socket.on("record_start", record_start_handle.bind(this));
            this.socket.on("record_stop", record_stop_handle.bind(this));
            this.socket.on("record_upload", record_upload_handle.bind(this));
            this.socket.on("players_disconnect", players_disconnect_handle.bind(this));
        }

        send_ping(connectionsCount, streamTypes, currentRecordId) {
            this.socket.emit("ping", { 
                ping: { 
                    connectionsCount: connectionsCount, 
                    streamTypes: streamTypes,
                    currentRecordId: currentRecordId
                } 
            });
        }

        send_offer_answer(playerId, answer) {
            this.socket.emit("offer_answer", { offerAnswer: { peerId: playerId, answer } });
        }

        send_grabber_ice(peerId, candidate) {
            this.socket.emit("grabber_ice", { ice: { peerId, candidate } });
        }

        async record_upload(fileName, fileBlob) {
            const formData = new FormData();
            formData.append('file', fileBlob, fileName);
            
            const url = `${this.signallingUrl}/api/agent/${this.peerName}/record_upload`;
            return fetch(url, {
                method: "POST",
                body: formData,
            });
        }
    }



class RecordingManager {
    constructor() {
        this.activeRecording = {
            recorders: [],
            recordId: null,
            recordedChunks: new Map(),
        };
    }

    getSupportedMimeType(isAudioEnabled) {
        const types = [
            'video/webm;codecs=vp8,opus',
            'video/webm;codecs=vp8',
            'video/webm',
        ];
        
        for (const type of types) {
            if (MediaRecorder.isTypeSupported(type)) {
                if (type.includes("opus") && !isAudioEnabled) {
                    continue;
                }
                console.log(`Using mime type: ${type}`);
                return type;
            }
        }
        
        console.warn('No supported mime type found, using default');
        return '';
    }

    async waitForStreamReady(stream, streamKey) {
        const videoTracks = stream.getVideoTracks();
        if (videoTracks.length === 0) {
            console.warn(`No video tracks in ${streamKey}`);
            return false;
        }

        const track = videoTracks[0];
        console.log(`Waiting for ${streamKey} track readyState: ${track.readyState}`);
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        if (track.readyState !== 'live') {
            console.warn(`${streamKey} track not live: ${track.readyState}`);
            return false;
        }
        
        return true;
    }

    async startRecording(recordId, timeout, streams, client) {
        this.stopRecording(this.activeRecording.recordId);
        
        this.activeRecording.recordId = recordId;
        this.activeRecording.recorders = [];
        this.activeRecording.recordedChunks.clear();

        const mimeType = this.getSupportedMimeType();

        for (const [streamKey, stream] of Object.entries(streams)) {
            const isReady = await this.waitForStreamReady(stream, streamKey);
            if (!isReady) {
                console.error(`Stream ${streamKey} not ready, skipping`);
                continue;
            }

            let recordStream = stream;
            
            if (streamKey === 'desktop' && stream.getAudioTracks().length === 0) {
                console.log('Desktop has no audio, adding silent track');
                recordStream = new MediaStream([
                    ...stream.getVideoTracks(),
                ]);
                console.log('Created new stream with silent audio');
            }

            const chunks = [];
            this.activeRecording.recordedChunks.set(streamKey, chunks);

            console.log(`Creating recorder for ${streamKey} with mime type: ${mimeType}`);
            
            const options = {};
            if (mimeType) {
                options.mimeType = mimeType;
            }
            
            let mediaRecorder;
            try {
                mediaRecorder = new MediaRecorder(recordStream, options);
            } catch (e) {
                console.error(`Failed to create MediaRecorder for ${streamKey}:`, e);
                try {
                    mediaRecorder = new MediaRecorder(recordStream);
                    console.log(`Created MediaRecorder for ${streamKey} with default options`);
                } catch (e2) {
                    console.error(`Failed to create MediaRecorder for ${streamKey} with defaults:`, e2);
                    continue;
                }
            }

            mediaRecorder.addEventListener('dataavailable', event => {
                if (event.data && event.data.size > 0) {
                    chunks.push(event.data);
                    console.log(`✓ Chunk received for ${streamKey}: ${event.data.size} bytes (total chunks: ${chunks.length})`);
                } else {
                    console.warn(`Empty chunk received for ${streamKey}`, event.data);
                }
            });

            mediaRecorder.addEventListener('start', () => {
                console.log(`MediaRecorder STARTED for ${streamKey}, state: ${mediaRecorder.state}`);
            });

            mediaRecorder.addEventListener('stop', () => {
                const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0);
                console.log(`Recording STOPPED for ${streamKey}, total chunks: ${chunks.length}, total size: ${totalSize} bytes`);
            });

            mediaRecorder.addEventListener('error', (event) => {
                console.error(`MediaRecorder ERROR for ${streamKey}:`, event.error);
            });

            const videoTracks = recordStream.getVideoTracks();
            const audioTracks = recordStream.getAudioTracks();
            console.log(`${streamKey} recording stream - video tracks: ${videoTracks.length}, audio tracks: ${audioTracks.length}`);
            videoTracks.forEach(track => {
                console.log(`  Video: ${track.label}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
            });
            audioTracks.forEach(track => {
                console.log(`  Audio: ${track.label}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
            });

            try {
                console.log(`Starting recorder for ${streamKey} with 1000ms timeslice...`);
                mediaRecorder.start(1000);
                this.activeRecording.recorders.push(mediaRecorder);
                console.info(`✓ Started recording ${recordId} [${streamKey}], initial state: ${mediaRecorder.state}`);
                
                setTimeout(() => {
                    console.log(`${streamKey} recorder state after 200ms: ${mediaRecorder.state}`);
                }, 200);
            } catch (e) {
                console.error(`Failed to start recording for ${streamKey}:`, e);
            }
        }

        if (this.activeRecording.recorders.length === 0) {
            console.error('No recorders started!');
            this.activeRecording.recordId = null;
            return;
        }

        console.log(`Successfully started ${this.activeRecording.recorders.length} recorder(s)`);

        setTimeout(() => {
            console.log(`Timeout reached (${timeout}ms), stopping recording ${recordId}`);
            this.stopRecording(recordId);
        }, timeout);
    }

    stopRecording(recordId) {
        if (this.activeRecording.recordId === null || 
            this.activeRecording.recordId !== recordId) {
            console.log(`Not stopping recording: current=${this.activeRecording.recordId}, requested=${recordId}`);
            return;
        }

        console.log(`Stopping ${this.activeRecording.recorders.length} recorders for ${recordId}`);
        
        this.activeRecording.recorders.forEach((r, index) => {
            try {
                console.log(`Recorder ${index} state before stop: ${r.state}`);
                if (r.state !== 'inactive') {
                    console.log(`Stopping recorder ${index}`);
                    r.stop();
                } else {
                    console.log(`Recorder ${index} already inactive`);
                }
            } catch (e) {
                console.error(`Error stopping recorder ${index}:`, e);
            }
        });
        
        this.activeRecording.recorders = [];
        const stoppedRecordId = this.activeRecording.recordId;
        this.activeRecording.recordId = null;
        
        console.info(`Stopped recording ${stoppedRecordId}`);
    }

    async uploadRecordings(recordId, client) {
        console.log('Waiting 1 second for final chunks...');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const chunksMap = new Map(this.activeRecording.recordedChunks);
        
        if (!chunksMap.size) {
            console.warn('No recordings to upload');
            return;
        }

        console.log(`Uploading recordings for ${recordId}:`, 
            Array.from(chunksMap.entries()).map(([k, v]) => `${k}: ${v.length} chunks`));

        for (const [streamKey, chunks] of chunksMap.entries()) {
            if (chunks.length === 0) {
                console.warn(`No chunks for ${streamKey}, skipping upload`);
                continue;
            }

            const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0);
            const blob = new Blob(chunks, { type: 'video/webm' });
            const fileName = `${recordId}_${streamKey}.webm`;
            
            console.log(`Uploading ${fileName}: ${chunks.length} chunks, ${blob.size} bytes (sum: ${totalSize})`);
            
            try {
                const response = await client.record_upload(fileName, blob);
                const text = await response.text();
                console.log(`✓ Upload ${fileName} response: ${text}`);
            } catch (e) {
                console.error(`Failed to upload ${fileName}: ${e}`);
            }
        }
        
        this.activeRecording.recordedChunks.clear();
    }
}
    const extractArguments = () => {
        const params = new URLSearchParams(window.location.search);
        if (!params.has("peerName")) {
            alert("Invalid parameters. No peerName argument");
        }
        return { peerName: params.get("peerName") };
    }
    const connectionArgs = extractArguments();

    function isSafari() {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }

    const askForAccess = () => new Promise(resolve => {
        const accessButton = document.getElementById('allowAccess');
        const captureButton = document.getElementById('captureButton');
        accessButton.style.display = 'inline-block';
        captureButton.style.display = 'none';
        accessButton.onclick = () => {
            accessButton.style.display = 'none';
            captureButton.style.display = 'inline-block';
            resolve();
        };
    });

    const detectStreams = async () => {
        const detectedStreams = {};

        const webcamStream = await navigator.mediaDevices.getUserMedia({
            video: webcamConstraint,
            audio: webcamAudioConstraint,
        }).catch(() => undefined);
        if (webcamStream) {
            detectedStreams["webcam"] = webcamStream;
        }

        if (desktopConstraint) {
            if (isSafari()) {
                await askForAccess();
            }
            const desktopStream = await navigator.mediaDevices.getDisplayMedia(desktopConstraint).catch(() => undefined);
            if (desktopStream) {
                detectedStreams["desktop"] = desktopStream;
            }
        }

        return detectedStreams;
    }

    let currentState = null;
    const updateState = (newState) => {
        currentState = newState;
        const captureButton = document.getElementById("captureButton");
        captureButton.className = newState;
        if (newState === "connecting") {
            captureButton.innerText = "connecting ...";
        } else if (newState === "active") {
            captureButton.innerText = "OK";
        } else if (newState === "recording") {
            captureButton.innerText = "Recording";
        }
    }

    const capture = async () => {
        if (currentState !== null) return;
        updateState("detecting");

        const streams = await detectStreams();
        const pcs = new Map();
        const recordingManager = new RecordingManager();
        let peerConnectionConfig = undefined;
        let pingTimerId = undefined;

        updateState("connecting");
        const client = new GrabberCaptureClient(connectionArgs.peerName);
        
        client.target.addEventListener("init_peer", async ({ detail: { pcConfig, pingInterval } }) => {
            peerConnectionConfig = pcConfig;
            pingInterval = pingInterval ?? 3000;
            if (pingTimerId) {
                clearInterval(pingTimerId);
            }
            pingTimerId = setInterval(() => {
                console.log("ping");
                client.send_ping(pcs.size, Object.keys(streams), recordingManager.activeRecording.recordId);
            }, pingInterval);
            console.log(`init peer (pingInterval = ${pingInterval})`);
            updateState("active");
        });

        client.target.addEventListener("offer", async ({ detail: { playerId, offer, streamType } }) => {
            console.log(`create new peer connection for ${playerId}`);
            pcs.set(playerId, new RTCPeerConnection(peerConnectionConfig));
            const pc = pcs.get(playerId);

            streamType = streamType ?? "desktop";
            const stream = streams[streamType];
            if (stream) {
                stream.getTracks().forEach(track => {
                    console.log("added track: ", track);
                    pc.addTrack(track, stream);
                });
            } else {
                console.warn(`No such ${streamType} as captured stream`);
            }

            pc.addEventListener("icecandidate", (event) => {
                console.log(`send ice for player ${playerId}`);
                client.send_grabber_ice(playerId, event.candidate);
            });

            pc.addEventListener('connectionstatechange', ({ target: connection }) => {
                console.log(`change player ${playerId} connection state ${connection.connectionState}`);
                if (connection.connectionState === "failed") {
                    connection.close();
                    pcs.delete(playerId);
                    console.log(`close connection for ${playerId}`);
                }
            });

            await pc.setRemoteDescription(offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            client.send_offer_answer(playerId, answer);
            console.log(`send offer_answer for ${playerId}`);
        });

        client.target.addEventListener('player_ice', async ({ detail: { peerId, candidate } }) => {
            pcs.get(peerId).addIceCandidate(candidate)
                .then(() => console.log(`add player_ice from ${peerId}`));
        });

        client.target.addEventListener('record_start', async ({ detail: { recordId, timeout } }) => {
    console.log(`Start recording: ${recordId}, timeout: ${timeout}ms`);
    updateState("recording");
    await recordingManager.startRecording(recordId, timeout, streams, client);
});
        client.target.addEventListener('record_stop', async ({ detail: { recordId } }) => {
            console.log(`Stop recording: ${recordId}`);
            recordingManager.stopRecording(recordId);
            updateState("active");
        });

        client.target.addEventListener('record_upload', async ({ detail: { recordId } }) => {
            console.log(`Upload recording: ${recordId}`);
            await recordingManager.uploadRecordings(recordId, client);
        });

        client.target.addEventListener('players_disconnect', async () => {
            console.log("Players disconnected");
            pcs.forEach((connection, playerId) => {
                try {
                    connection.close();
                    console.log(`Closed connection for ${playerId}`);
                } catch (e) {
                    console.error(`Failed to close connection for ${playerId}`);
                }
            });
            pcs.clear();
            recordingManager.stopRecording(recordingManager.activeRecording.recordId);
        });
    };

    document.getElementById("captureButton").addEventListener("click", capture);
</script>